<!doctype html>
<html lang="en">
<head>
  <!--
    ballonslack — static-equilibrium visualizer for a chimney–mass–balloon system (dark, minimalist)

    Update: Discrete L2 precomputation (fast live scrubbing)
      • On Simulate, we now precompute equilibrium paths for:
          – 21 wind steps (−5000…+5000 N in 500 N steps), and
          – 20 discrete L2 values, equally spaced between:
                L2_min = distance(chimney anchor, ground anchor) − L1   (clamped ≥ 10 m)
                L2_max = 400 m
      • While the animation runs, the L2 slider becomes discrete over those 20 values.
        You can scrub L2 during playback without resetting or pausing.
        When you stop/reset (by changing geometry), the L2 slider returns to continuous mode.

      Performance notes (no behavior change):
        – β-window caching per (L1, L2, D2, H1).
        – Single-pass β evaluation (coords + validity + energy), early rejects, precomputed cos/sin.
        – Tensions from final coords (no re-validation pass).
  -->
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Best-effort cache busters for the HTML document itself -->
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
  <meta http-equiv="Pragma" content="no-cache" />
  <meta http-equiv="Expires" content="0" />

  <title>ballonslack</title>
  <style>
    :root {
      --bg: #0b0e14;
      --panel: #10141f;
      --text: #e6edf3;
      --muted: #9aa6b2;
      --accent: #7aa2f7;
      --good: #28c581;
      --warn:  #ffb454;
      --bad:   #f7768e;
      --line:  #1f2433;
    }
    * { box-sizing: border-box; }
    html, body { height: 100vh; margin: 0; background: var(--bg); color: var(--text); font: 14px/1.4 system-ui,-apple-system,Segoe UI,Roboto,Inter,"Helvetica Neue",Arial,"Noto Sans"; overflow: hidden; }
    .app { display: flex; height: 100%; }
    .left {
      width: 360px; max-width: 400px; padding: 12px 14px; background: var(--panel);
      border-right: 1px solid var(--line); height: 100%; overflow: auto;
    }
    .right { position: relative; flex: 1; display: flex; padding: 12px; height: 100%; }
    .canvas-wrap { position: relative; flex: 1; display: flex; align-items: stretch; justify-content: stretch; }
    canvas { width: 100%; height: 100%; background: linear-gradient(180deg, #0b0e14 0%, #0b0e14 70%, #0d1117 70%); border-radius: 12px; box-shadow: 0 10px 30px rgba(0,0,0,.35); }
    h1 { margin: 0 0 6px; font-size: 18px; font-weight: 700; letter-spacing: .2px; }
    .small { font-size: 12px; color: var(--muted); }
    .box { background: #0d1220; border: 1px dashed #1f2942; border-radius: 10px; padding: 10px 12px; color: var(--muted); }
    .ok   { color: var(--good); }
    .bad  { color: var(--bad); }
    .warnText { color: var(--warn); }

    /* Sliders */
    input[type="range"] { width: 100%; -webkit-appearance: none; background: transparent; height: 28px; }
    input[type="range"]::-webkit-slider-runnable-track { height: 6px; background: #1c2233; border-radius: 4px; border: 1px solid #212a40; }
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none; margin-top: -6px; width: 18px; height: 18px; border-radius: 50%;
      background: var(--accent); border: 0; box-shadow: 0 0 0 4px rgba(122,162,247,.2);
    }

    .group { padding: 10px 12px; border: 1px solid #1f2942; border-radius: 12px; background: #0d1220; margin: 10px 0; position: relative; }
    .group::before { content:""; position:absolute; left:0; top:0; bottom:0; width:4px; border-radius:12px 0 0 12px; background: var(--slider, #3a4160); }
    .group .title { display:flex; align-items:center; gap:8px; font-weight:700; margin-bottom:6px; }
    .group .title .chip { width:10px; height:10px; border-radius:50%; background: var(--slider, #3a4160); }
    .group input[type="range"]::-webkit-slider-runnable-track {
      background: linear-gradient(0deg, var(--slider-tint, rgba(255,255,255,0.06)), var(--slider-tint, rgba(255,255,255,0.06))), #1c2233;
    }
    .group input[type="range"]::-webkit-slider-thumb {
      background: var(--slider, #3a4160); box-shadow: 0 0 0 4px var(--ring, rgba(255,255,255,0.15));
    }
    .r1 { --slider:#8bd5ff; --slider-tint: rgba(139,213,255,0.12); --ring: rgba(139,213,255,0.20); }
    .r2 { --slider:#c3e88d; --slider-tint: rgba(195,232,141,0.12); --ring: rgba(195,232,141,0.20); }
    .rw { --slider:#f6c177; --slider-tint: rgba(246,193,119,0.12); --ring: rgba(246,193,119,0.20); }

    .label { display: flex; align-items: baseline; justify-content: space-between; margin-bottom: 6px; color: var(--muted); font-size: 12px; gap: 6px; }
    .nums { font-variant-numeric: tabular-nums; color: var(--text); }
    .unit { color: var(--muted); margin-left: 4px; }

    .btns { display: grid; grid-template-columns: 1fr; gap: 8px; margin-top: 10px; }
    button {
      background: #1b2333; color: var(--text); border: 1px solid #263045; border-radius: 10px; padding: 10px 12px;
      cursor: pointer; font-weight: 600; letter-spacing: .2px;
    }
    button.primary { background: var(--accent); border-color: var(--accent); color: #0b0e14; }
    button:disabled { opacity: .6; cursor: not-allowed; }

    /* HUD (Tension panel) — JS positions it at the grid's top-right corner */
    .hud {
      position: absolute;
      background: rgba(9,12,20,0.85);
      border: 1px solid #1b2440;
      backdrop-filter: blur(4px);
      border-radius: 10px;
      padding: 10px 12px;
      min-width: 220px;
      box-shadow: 0 6px 20px rgba(0,0,0,.25);
      font-size: 12px; color: #cbd5e1;
      z-index: 5;
      pointer-events: none;
    }
    .hud .title { font-weight: 800; color:#e6edf3; margin-bottom: 4px; }
    .hud .row { display:flex; justify-content:space-between; gap: 12px; margin: 4px 0; }
    .hud .name { color:#94a3b8; }
    .hud .val  { font-variant-numeric: tabular-nums; color:#e6edf3; }
  </style>
</head>
<body>
<div class="app">
  <!-- LEFT CONTROL PANEL -->
  <div class="left">
    <h1>ballonslack</h1>

    <div class="box small" id="statusBox">
      Set lengths, anchors, and wind. Click <b>Simulate</b> to precompute (for winds × 20 L2 steps) and animate; adjust wind/L2 live.
    </div>

    <!-- Rope R1 (chimney ↔ balloon) + mass position D1 + H1 (chimney anchor height) -->
    <div class="group r1">
      <div class="title"><span class="chip"></span>R1 — chimney ↔ balloon</div>

      <div class="label"><span>L1 (max length)</span><span class="nums" id="valL1">100</span><span class="unit">m</span></div>
      <input type="range" min="10" max="400" step="1" value="100" id="l1">

      <div class="label"><span>D1 (mass along R1)</span><span class="nums" id="valD1">50</span><span class="unit">m</span></div>
      <input type="range" min="0" max="100" step="1" value="50" id="d1">

      <div class="label"><span>H1 (chimney anchor height)</span><span class="nums" id="valH1">300</span><span class="unit">m</span></div>
      <input type="range" min="150" max="300" step="1" value="300" id="h1">
    </div>

    <!-- Rope R2 (ground ↔ balloon) -->
    <div class="group r2">
      <div class="title"><span class="chip"></span>R2 — ground ↔ balloon</div>
      <div class="label"><span>L2 (max length)</span><span class="nums" id="valL2">305</span><span class="unit">m</span></div>
      <input type="range" min="10" max="400" step="1" value="305" id="l2">
      <div class="label"><span>D2 (ground anchor x)</span><span class="nums" id="valD2">130</span><span class="unit">m</span></div>
      <input type="range" min="0" max="400" step="1" value="130" id="d2">
    </div>

    <!-- Wind controls -->
    <div class="group rw">
      <div class="title"><span class="chip"></span>Wind on balloon</div>
      <div class="label"><span>F<sub>w,b</sub> (left ⟵ 0 ⟶ right)</span><span class="nums" id="valFW">0</span><span class="unit">N</span></div>
      <input type="range" min="-5000" max="5000" step="500" value="0" id="fw">
      <label class="checkline"><input type="checkbox" id="windVisible" checked> wind visible</label>
    </div>

    <!-- Actions -->
    <div class="btns">
      <button class="primary" id="btnSimulate">Simulate</button>
      <button id="btnPlayPause" disabled>Pause</button>
    </div>

    <!-- Two simple bullets with key facts -->
    <div class="foot small" style="margin-top:10px;">
      <ul style="margin:6px 0 0 16px; padding:0;">
        <li>Balloon thrust 15&nbsp;kN; balloon mass 510&nbsp;kg (net ≈ +10&nbsp;kN up)</li>
        <li>Payload mass 80&nbsp;kg at D1 on R1</li>
      </ul>
    </div>
  </div>

  <!-- RIGHT: CANVAS & HUD (HUD sits at grid top-right with padding) -->
  <div class="right">
    <div class="canvas-wrap">
      <canvas id="cv" aria-label="Static equilibrium canvas"></canvas>

      <!-- Tension readout in kN (rounded to one decimal) -->
      <div class="hud" id="hud">
        <div class="title">Tension</div>
        <div class="row"><span class="name">R1 @ chimney</span><span class="val" id="hudR1">—</span></div>
        <div class="row"><span class="name">R2 @ ground</span><span class="val" id="hudR2">—</span></div>
      </div>
    </div>
  </div>
</div>

<script>
(() => {
  // VERSION string for cache-busting assets (append ?v=VERSION)
  const VERSION = 'v2025-10-20-09';

  // -------- World & UI handles --------
  const world = { W: 400, H: 400 };
  const ui = {
    canvas: document.getElementById('cv'),
    ctx: null,
    devicePR: Math.max(1, Math.min(2, window.devicePixelRatio || 1)),
    status: document.getElementById('statusBox'),
    btnSim: document.getElementById('btnSimulate'),
    btnPlayPause: document.getElementById('btnPlayPause'),
    l1: document.getElementById('l1'),
    d1: document.getElementById('d1'),
    h1: document.getElementById('h1'),
    l2: document.getElementById('l2'),
    d2: document.getElementById('d2'),
    fw: document.getElementById('fw'),
    windVisible: document.getElementById('windVisible'),
    vL1: document.getElementById('valL1'),
    vD1: document.getElementById('valD1'),
    vH1: document.getElementById('valH1'),
    vL2: document.getElementById('valL2'),
    vD2: document.getElementById('valD2'),
    vFW: document.getElementById('valFW'),
    hudR1: document.getElementById('hudR1'),
    hudR2: document.getElementById('hudR2'),
    hudBox: document.getElementById('hud'),
  };

  // -------- Assets (with cache-busting) --------
  const assets = {
    balloon: new Image(),
    chimney: new Image(),
    konn: new Image(),
    balloonH: 24, // meters tall render
    konnH: 12     // meters tall render
  };
  assets.balloon.src = 'balloon.svg?' + VERSION;
  assets.chimney.src = 'chimney.svg?' + VERSION;
  assets.konn.src    = 'konn.png?'    + VERSION;
  assets.balloon.onload = drawPreviewWithWind;
  assets.chimney.onload = drawPreviewWithWind;
  assets.konn.onload    = drawPreviewWithWind;

  // -------- Parameters (SI units) --------
  const params = {
    l1: 100, d1: 50,
    h1: 300,
    l2: 305, d2: 130,
    Fw_b: 0,
    windVisible: true,
    gridStep: 25,
    gravity: 9.81,
    weightMass: 80,        // kg (payload)
    balloonMass: 510,      // kg
    balloonUpThrust: 15000 // N
  };

  // Discrete wind levels (precomputation grid)
  const WIND_STEPS = Array.from({length: 21}, (_,i)=> -5000 + i*500);
  const nearestWindStep = v => Math.max(-5000, Math.min(5000, Math.round(v/500)*500));

  // Discrete L2 values (20 steps) computed at simulate-time for current geometry
  let L2_STEPS = [];          // numbers
  let L2min = 10, L2max = 400, L2stepSize = 0;
  let currentL2Index = 0;     // index into L2_STEPS while animating
  let l2SliderSaved = { min:'10', max:'400', step:'1' }; // restore after animation

  // -------- Animation state --------
  const N_FRAMES = 100;
  let anim = {
    running: false, paused: false,
    index: 0, dir: 1,
    lastTime: 0, frameInterval: 33,
    idxMin: Math.round(0.20 * (N_FRAMES - 1)),
    idxMax: Math.round(0.80 * (N_FRAMES - 1)),
    autoResumeAfterDrag: false,
    windStep: 0
  };
  let frames = [];
  // Nested precomputation: L2 → wind → frames[]
  const precompByL2Wind = new Map();
  let suppressSliderInput = false;
  let isDraggingSlider = false;

  // -------- Wind particles (visual only) --------
  const wind = {
    particles: [],
    lastTime: 0,
    loopActive: false,
    alpha: 0,
    alphaTarget: 0,
    N: 90,
    MAX_SPEED: 140,
    TRAIL_T: 0.18
  };
  function initWindParticles() {
    wind.particles = [];
    for (let i = 0; i < wind.N; i++) {
      wind.particles.push({
        x: Math.random()*world.W,
        y: Math.random()*(world.H-8)+4,
        sf: 0.6 + Math.random()*0.8,
        wobble: Math.random()*Math.PI*2
      });
    }
  }
  function updateWindTargets() {
    const f = Math.min(1, Math.abs(params.Fw_b)/5000);
    wind.alphaTarget = (params.windVisible ? Math.pow(f, 0.8) : 0);
  }
  function updateWind(dt) {
    const k = Math.min(1, dt*4);
    wind.alpha += (wind.alphaTarget - wind.alpha)*k;
    const dir = Math.sign(params.Fw_b) || 1;
    const speed = (Math.abs(params.Fw_b)/5000)*wind.MAX_SPEED;
    const vyScale = 0.03;
    for (const p of wind.particles) {
      const vx = dir*speed*p.sf;
      p.wobble += dt*(0.6 + 0.8*p.sf);
      p.x += vx*dt;
      p.y += Math.sin(p.wobble)*vyScale;
      const margin = 12;
      if (dir>0 && p.x>world.W+margin){ p.x=-margin; p.y=Math.random()*(world.H-8)+4; }
      if (dir<0 && p.x<-margin){ p.x=world.W+margin; p.y=Math.random()*(world.H-8)+4; }
      if (p.y<2) p.y=2; if (p.y>world.H-2) p.y=world.H-2;
    }
  }
  function drawWindParticles() {
    if (wind.alpha < 0.02) return;
    const ctx = ui.ctx;
    const dir = Math.sign(params.Fw_b) || 1;
    const speed = (Math.abs(params.Fw_b)/5000)*wind.MAX_SPEED;
    const trail = wind.TRAIL_T * speed;
    ctx.save();
    ctx.globalAlpha = 0.06 + 0.30 * wind.alpha;
    ctx.lineWidth = 2;
    ctx.strokeStyle = 'rgba(200,208,220,0.7)';
    ctx.lineCap = 'round';
    for (const p of wind.particles) {
      const x2 = toScreen({x:p.x, y:p.y});
      const x1 = toScreen({x:p.x - dir*(trail*p.sf), y:p.y});
      ctx.beginPath(); ctx.moveTo(x1.x, x1.y); ctx.lineTo(x2.x, x2.y); ctx.stroke();
    }
    ctx.restore();
  }
  function startWindLoop() {
    if (wind.loopActive) return;
    wind.loopActive = true; wind.lastTime = 0;
    requestAnimationFrame(function loop(t){
      if (!wind.loopActive) return;
      if (!wind.lastTime) wind.lastTime = t;
      const dt = Math.min(0.05, (t - wind.lastTime)/1000);
      wind.lastTime = t;
      updateWindTargets(); updateWind(dt);
      drawPreview(); drawWindParticles();
      requestAnimationFrame(loop);
    });
  }
  function stopWindLoop(){ wind.loopActive = false; }

  // -------- Utilities --------
  const clamp  = (v,a,b)=>Math.max(a,Math.min(b,v));
  const nearly = (a,b,eps=1e-3)=>Math.abs(a-b) <= eps;
  const fmtKN1 = n => (Number(n)/1000).toLocaleString(undefined,{minimumFractionDigits:1,maximumFractionDigits:1}) + ' kN';
  const clamp01 = x => Math.max(-1, Math.min(1, x));
  const lerp = (a,b,t)=>a+(b-a)*t;

  function toScreen(p){
    const c = ui.canvas, pad = 12;
    const w = c.clientWidth - pad*2, h = c.clientHeight - pad*2;
    const s = Math.min(w/world.W, h/world.H);
    const ox = (c.clientWidth - s*world.W)*0.5;
    const oy = (c.clientHeight + s*world.H)*0.5;
    return { x: ox + p.x*s, y: oy - p.y*s, scale: s, ox, oy };
  }
  function anchors(){ return { A1:{x:0,y:clamp(params.h1,150,300)}, A2:{x:clamp(params.d2,0,400), y:0} }; }
  function netBalloonUpForce(){ return params.balloonUpThrust - params.balloonMass*params.gravity; }

  // --- Position HUD at the grid’s top-right corner (world W,H) with padding ---
  function positionHUD(padPx = 8) {
    if (!ui.ctx) return;
    const hud = ui.hudBox;
    if (!hud) return;
    const tr = toScreen({x: world.W, y: world.H}); // world top-right
    const hudWidth = hud.offsetWidth || 220;
    const left = Math.round(tr.x - hudWidth - padPx);
    const top  = Math.round(tr.y + padPx);
    hud.style.left = left + 'px';
    hud.style.top  = top  + 'px';
    hud.style.right = '';
  }

  // ===============================================================
  //                 OPTIMIZED SOLVER IMPLEMENTATION
  // ===============================================================

  // Geometry cache for β-window and coarse samples
  const geomCache = {
    key: '',     // `${L1}|${L2}|${D2}|${H1}`
    betaWin: null,
    N: 50,
    betas: null, // Float64Array length N
    cosb: null,  // Float64Array length N
    sinb: null   // Float64Array length N
  };

  function betaBounds(L1, L2, D2, H1){
    if (L2 <= 0) return null;
    const thetaTop = Math.atan2(H1, D2);
    const beta_x0  = Math.acos(clamp01(D2 / L2));       // x_b = 0
    const beta_min = Math.max(beta_x0, thetaTop);

    const dist = Math.hypot(D2, H1);
    if (dist <= 0) return null;
    const cosArg = (dist*dist + L2*L2 - L1*L1) / (2*dist*L2);
    const phi    = Math.acos(clamp01(cosArg));
    let beta_max = thetaTop + phi;

    const PI = Math.PI;
    const minClamped = Math.max(0, Math.min(PI, beta_min));
    const maxClamped = Math.max(0, Math.min(PI, beta_max));
    if (maxClamped <= minClamped + 1e-4) return null;
    return { min: minClamped, max: maxClamped };
  }

  function updateBetaWindowCache(L1, L2, D2, H1){
    const newKey = `${L1}|${L2}|${D2}|${H1}`;
    if (geomCache.key === newKey && geomCache.betaWin) return true;

    const win = betaBounds(L1, L2, D2, H1);
    geomCache.key = newKey;
    geomCache.betaWin = win;
    if (!win){
      geomCache.betas = geomCache.cosb = geomCache.sinb = null;
      return false;
    }
    const N = geomCache.N;
    const betas = new Float64Array(N);
    const cosb  = new Float64Array(N);
    const sinb  = new Float64Array(N);
    const span = (win.max - win.min);
    const step = span / (N + 1);
    for (let i=0;i<N;i++){
      const b = win.min + (i+1)*step; // open interval
      betas[i]=b; cosb[i]=Math.cos(b); sinb[i]=Math.sin(b);
    }
    geomCache.betas = betas; geomCache.cosb = cosb; geomCache.sinb = sinb;
    return true;
  }

  // Single-pass β evaluation using precomputed cos/sin (EARLY REJECTS)
  function evalBetaOnce(cosb, sinb, beta, l1a, l1b, L2, D2, H1, Fg_s, Fg_b, Fw_b){
    const xb = D2 - L2 * cosb;
    const yb = L2 * sinb;
    if (xb < 0 || yb < 0) return null;

    const dy = H1 - yb;
    const side = Math.hypot(xb, dy);
    if (side < Math.abs(l1a - l1b) - 1e-6 || side > (l1a + l1b) + 1e-6) return null;

    const gamma1 = Math.atan2(dy, xb);
    let arg = (l1a*l1a + side*side - l1b*l1b)/(2*l1a*side);
    arg = clamp01(arg);
    const gamma2 = Math.acos(arg);
    const alpha  = gamma1 + gamma2;

    const xs = l1a * Math.cos(alpha);
    const ys = H1  - l1a * Math.sin(alpha);

    const distB = Math.hypot(D2 - xb, yb);
    if (!nearly(distB, L2, 1e-3)) return null;
    if (xs < 0 || ys < 0 || xs > xb + 1e-9) return null;

    const E = Fg_s*ys + Fg_b*yb - Fw_b*xb;
    return { E, xs, ys, xb, yb };
  }

  function tensionsFromCoords(xs, ys, xb, yb, A1, A2, Fg_s, Fg_b, Fw_b, tol=1e-9){
    const W = Math.abs(Fg_s), B = Math.abs(Fg_b);

    const v1m = {x:A1.x-xs, y:A1.y-ys}; const L1 = Math.hypot(v1m.x,v1m.y); if (L1<1e-9) return null;
    const u1m = {x:v1m.x/L1, y:v1m.y/L1};
    const v2m = {x:xb-xs,   y:yb-ys};   const L2 = Math.hypot(v2m.x,v2m.y); if (L2<1e-9) return null;
    const u2m = {x:v2m.x/L2, y:v2m.y/L2};
    const u2b = {x:-u2m.x, y:-u2m.y};
    const v3b = {x:A2.x-xb, y:A2.y-yb}; const L3 = Math.hypot(v3b.x,v3b.y); if (L3<1e-9) return null;
    const u3b = {x:v3b.x/L3, y:v3b.y/L3};

    const A00=u2b.x, A01=u3b.x, A10=u2b.y, A11=u3b.y;
    const b0=-Fw_b,  b1=-B;
    const det = A00*A11 - A01*A10;
    if (Math.abs(det) < 1e-12) return null;

    const T2 = ( b0*A11 - A01*b1)/det;
    const T3 = (-b0*A10 + A00*b1)/det;

    let T1;
    if (Math.abs(u1m.x) > Math.abs(u1m.y)) T1 = -T2*u2m.x/u1m.x;
    else                                    T1 = (W - T2*u2m.y)/u1m.y;

    if (T1 < -tol || T2 < -tol || T3 < -tol) return null;

    const z = v => (Math.abs(v) < tol ? 0 : v);
    return { T1: Math.abs(z(T1)), T2: Math.abs(z(T2)), T3: Math.abs(z(T3)) };
  }

  // Solve equilibrium for a specific D1, wind, and L2 (override)
  function solveForD1(d1Override, FwOverride, L2Override){
    const {A1,A2} = anchors();
    const L1  = params.l1;
    const L2  = L2Override;
    const D2  = A2.x;
    const H1  = A1.y;

    const l1a = Math.max(1e-6, Math.min(d1Override, L1));
    const l1b = Math.max(1e-6, Math.max(0, L1 - d1Override));

    const Fg_s = params.weightMass*params.gravity;
    const F_buoy_net = netBalloonUpForce();
    const Fg_b = -F_buoy_net;
    const Fw_b = FwOverride;

    if (!updateBetaWindowCache(L1, L2, D2, H1)) return null;

    const N = geomCache.N;
    const betas = geomCache.betas, cosb = geomCache.cosb, sinb = geomCache.sinb;
    let bestE = Number.POSITIVE_INFINITY, bestEval = null, bestIdx = -1;

    for (let i=0;i<N;i++){
      const ev = evalBetaOnce(cosb[i], sinb[i], betas[i], l1a, l1b, L2, D2, H1, Fg_s, Fg_b, Fw_b);
      if (!ev) continue;
      if (ev.E < bestE){ bestE = ev.E; bestEval = ev; bestIdx = i; }
    }
    if (!bestEval) return null;

    // refine in neighborhood of bestIdx
    const win = geomCache.betaWin;
    const leftB  = (bestIdx===0      ? win.min : betas[bestIdx-1]);
    const rightB = (bestIdx===N-1    ? win.max : betas[bestIdx+1]);
    const span = rightB - leftB;
    if (span > 1e-9){
      const N2 = 50;
      for (let j=1;j<=N2;j++){
        const bj = leftB + j*span/(N2+1);
        const cb = Math.cos(bj), sb = Math.sin(bj);
        const ev = evalBetaOnce(cb, sb, bj, l1a, l1b, L2, D2, H1, Fg_s, Fg_b, Fw_b);
        if (!ev) continue;
        if (ev.E < bestE){ bestE = ev.E; bestEval = ev; }
      }
    }

    const t = tensionsFromCoords(bestEval.xs, bestEval.ys, bestEval.xb, bestEval.yb, A1, A2, Fg_s, Fg_b, Fw_b);
    if (!t) return null;

    return { d1:d1Override, xs:bestEval.xs, ys:bestEval.ys, xb:bestEval.xb, yb:bestEval.yb, T1:t.T1, T2:t.T2, T3:t.T3 };
  }

  // ===============================================================
  //                     L2 DISCRETIZATION & PRECOMPUTE
  // ===============================================================

  function computeL2Steps(){
    const {A1,A2} = anchors();
    const dist = Math.hypot(A2.x - 0, A1.y - 0); // distance ground anchor ↔ chimney anchor
    let minCandidate = dist - params.l1;
    // Clamp minimal feasible to ≥ 10 m to avoid degenerate rope
    L2min = Math.max(10, minCandidate);
    L2max = 400;

    if (L2min > L2max - 1e-6){
      L2_STEPS = [];
      return false;
    }
    const N = 50;
    L2stepSize = (L2max - L2min) / (N - 1);
    L2_STEPS = Array.from({length:N}, (_,i)=> L2min + i*L2stepSize);
    return true;
  }

  function nearestL2Index(value){
    if (!L2_STEPS.length) return -1;
    const t = (value - L2min) / (L2max - L2min);
    const idx = Math.round(clamp(t,0,1)*(L2_STEPS.length-1));
    return clamp(idx, 0, L2_STEPS.length-1);
  }

  function precomputeForL2Wind(L2value, wStep){
    const arr = new Array(N_FRAMES).fill(null);
    for (let i=0;i<N_FRAMES;i++){
      const frac = (N_FRAMES===1)?0.5 : i/(N_FRAMES-1);
      const d1i = frac*params.l1;
      arr[i] = solveForD1(d1i, wStep, L2value);
    }
    return arr;
  }

  function precomputeAllL2Winds(){
    precompByL2Wind.clear();
    if (!computeL2Steps()){
      setStatus('No feasible L2 range for this geometry. Increase L1 or adjust anchors.', 'bad');
      return;
    }
    const {A1,A2} = anchors();
    const L1 = params.l1, D2 = A2.x, H1 = A1.y;

    for (const L2 of L2_STEPS){
      // Prepare β cache for this (L1,L2,D2,H1)
      updateBetaWindowCache(L1, L2, D2, H1);
      const mapWind = new Map();
      for (const w of WIND_STEPS){
        mapWind.set(w, precomputeForL2Wind(L2, w));
      }
      precompByL2Wind.set(L2, mapWind);
    }
  }

  // ===============================================================
  //                           RENDERING
  // ===============================================================

  function setStatus(text, kind=''){
    ui.status.textContent = text;
    ui.status.className = 'box small ' + (kind==='ok'?'ok':kind==='bad'?'bad':kind==='warn'?'warnText':'');
  }
  function drawGrid(){
    const ctx = ui.ctx; if (!ctx) return;
    const step = params.gridStep;
    ctx.save(); ctx.lineWidth=1; ctx.strokeStyle='rgba(255,255,255,0.035)';
    for (let x=0;x<=world.W;x+=step){ const p0=toScreen({x,y:0}), p1=toScreen({x,y:world.H}); ctx.beginPath(); ctx.moveTo(p0.x,p0.y); ctx.lineTo(p1.x,p1.y); ctx.stroke(); }
    for (let y=0;y<=world.H;y+=step){ const p0=toScreen({x:0,y}), p1=toScreen({x:world.W,y}); ctx.beginPath(); ctx.moveTo(p0.x,p0.y); ctx.lineTo(p1.x,p1.y); ctx.stroke(); }
    ctx.restore();
  }
  function drawShadedDisc(center, radius, strokeColor, fillColor){
    const ctx = ui.ctx, P = toScreen(center);
    ctx.beginPath(); ctx.arc(P.x,P.y, Math.max(1, radius*P.scale), 0, Math.PI*2);
    ctx.fillStyle=fillColor; ctx.fill();
    ctx.setLineDash([6,6]); ctx.lineWidth=1.2; ctx.strokeStyle=strokeColor; ctx.stroke(); ctx.setLineDash([]);
  }
  function drawAnchorDot(center, color, label){
    const ctx = ui.ctx, P = toScreen(center);
    ctx.fillStyle=color; ctx.beginPath(); ctx.arc(P.x,P.y,5,0,Math.PI*2); ctx.fill();
    ctx.font='12px system-ui, sans-serif'; ctx.textBaseline='middle'; ctx.fillStyle='#9aa6b2'; ctx.fillText(label, P.x+6, P.y);
  }
  function drawTag(text, x, y, opts={}){
    const ctx = ui.ctx, padX=6; ctx.font='12px system-ui, sans-serif'; const w=ctx.measureText(text).width; const r=6;
    const bg=opts.bg||'rgba(13,18,32,0.85)', border=opts.border||'rgba(255,255,255,0.08)';
    ctx.save(); ctx.fillStyle=bg; ctx.strokeStyle=border; ctx.lineWidth=1;
    ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w+padX*2,y,x+w+padX*2,y+20,r);
    ctx.arcTo(x+w+padX*2,y+20,x,y+20,r); ctx.arcTo(x,y+20,x,y,r); ctx.arcTo(x,y,x+r,y,r); ctx.closePath();
    ctx.fill(); ctx.stroke(); ctx.fillStyle='#cbd5e1'; ctx.fillText(text, x+padX, y+14); ctx.restore();
  }

  function drawChimneySVG(){
    const img=assets.chimney; if (!img||!img.complete) return;
    const s = toScreen({x:0,y:0}).scale; const Hm=300;
    const iw=img.naturalWidth||img.width||1, ih=img.naturalHeight||img.height||1, aspect=iw/ih, Wm=Hm*aspect;
    const xLeftW = 0 - Wm;
    const yTopW  = 300;
    const topLeft = toScreen({x:xLeftW, y:yTopW});
    ui.ctx.drawImage(img, topLeft.x, topLeft.y, Wm*s, Hm*s);
  }
  function drawBalloonSVG(balloonPos){
    const img=assets.balloon; if (!img||!img.complete) return;
    const s = toScreen({x:0,y:0}).scale; const Hm=assets.balloonH;
    const iw=img.naturalWidth||img.width||1, ih=img.naturalHeight||img.height||1, aspect=iw/ih, Wm=Hm*aspect;
    const xLeftW=balloonPos.x - Wm/2, yTopW=balloonPos.y + Hm; const topLeft = toScreen({x:xLeftW, y:yTopW});
    ui.ctx.drawImage(img, topLeft.x, topLeft.y, Wm*s, Hm*s);
  }
  function drawKonnAt(pos){
    const img=assets.konn; if (!img||!img.complete) return;
    const s = toScreen({x:0,y:0}).scale; const Hm=assets.konnH;
    const iw=img.naturalWidth||img.width||1, ih=img.naturalHeight||img.height||1, aspect=iw/ih, Wm=Hm*aspect;
    const xLeftW=pos.x - Wm/2, yTopW=pos.y + Hm; const topLeft = toScreen({x:xLeftW, y:yTopW});
    ui.ctx.drawImage(img, topLeft.x, topLeft.y, Wm*s, Hm*s);
  }

  function drawPreview(){
    const ctx = ui.ctx; if (!ctx) return;
    ctx.clearRect(0,0,ui.canvas.clientWidth, ui.canvas.clientHeight);
    drawGrid();
    // ground line
    ctx.strokeStyle='#182033'; ctx.lineWidth=2;
    const g0=toScreen({x:0,y:0}), g1=toScreen({x:world.W,y:0}); ctx.beginPath(); ctx.moveTo(g0.x,g0.y); ctx.lineTo(g1.x,g1.y); ctx.stroke();
    drawChimneySVG();

    // discs & anchors
    const {A1,A2}=anchors();
    drawShadedDisc(A1, params.l1, '#8bd5ff88', 'rgba(139,213,255,0.08)');
    drawShadedDisc(A2, params.l2, '#c3e88d88', 'rgba(195,232,141,0.08)');
    drawAnchorDot(A1, '#8bd5ff', 'R1′'); drawAnchorDot(A2, '#c3e88d', 'R2′');

    // scale bar (100 m)
    const bp0=toScreen({x:10,y:8}), bp1=toScreen({x:110,y:8});
    ctx.strokeStyle='#2a3146'; ctx.lineWidth=3; ctx.beginPath(); ctx.moveTo(bp0.x,bp0.y); ctx.lineTo(bp1.x,bp1.y); ctx.stroke();
    ctx.fillStyle='#78839b'; ctx.font='12px system-ui, sans-serif'; ctx.fillText('100 m', (bp0.x+bp1.x)/2-16, bp0.y-8);

    // HUD reset + position
    ui.hudR1.textContent = '—'; ui.hudR2.textContent = '—';
    positionHUD(10);
  }
  function drawPreviewWithWind(){ drawPreview(); drawWindParticles(); }

  function drawState(state){
    const ctx = ui.ctx; if (!ctx||!state) return;
    const {A1,A2}=anchors();
    ctx.clearRect(0,0,ui.canvas.clientWidth, ui.canvas.clientHeight);
    drawGrid();
    // ground
    ctx.strokeStyle='#182033'; ctx.lineWidth=2;
    const g0=toScreen({x:0,y:0}), g1=toScreen({x:world.W,y:0}); ctx.beginPath(); ctx.moveTo(g0.x,g0.y); ctx.lineTo(g1.x,g1.y); ctx.stroke();
    drawChimneySVG();
    // discs & anchors
    drawShadedDisc(A1, params.l1, '#8bd5ff88', 'rgba(139,213,255,0.08)');
    drawShadedDisc(A2, params.l2, '#c3e88d88', 'rgba(195,232,141,0.08)');
    drawAnchorDot(A1, '#8bd5ff', 'R1′'); drawAnchorDot(A2, '#c3e88d', 'R2′');

    const massP={x:state.xs,y:state.ys}, ballP={x:state.xb,y:state.yb};

    // R1a: chimney→mass
    ctx.strokeStyle='#8bd5ff'; ctx.lineWidth=2;
    let p=toScreen(A1), q=toScreen(massP); ctx.beginPath(); ctx.moveTo(p.x,p.y); ctx.lineTo(q.x,q.y); ctx.stroke();
    // R1b: mass→balloon
    p=toScreen(massP); q=toScreen(ballP); ctx.beginPath(); ctx.moveTo(p.x,p.y); ctx.lineTo(q.x,q.y); ctx.stroke();
    // R2: balloon→ground
    ctx.strokeStyle='#c3e88d'; ctx.beginPath(); p=toScreen(ballP); q=toScreen(A2); ctx.moveTo(p.x,p.y); ctx.lineTo(q.x,q.y); ctx.stroke();

    drawKonnAt(massP);
    drawBalloonSVG(ballP);

    // coordinate tags (rounded to 1 m)
    const bS=toScreen(ballP); drawTag(`(${Math.round(ballP.x)} m, ${Math.round(ballP.y)} m)`, bS.x+12, bS.y-26);
    const mS=toScreen(massP); drawTag(`(${Math.round(massP.x)} m, ${Math.round(massP.y)} m)`, mS.x-36, mS.y+12);

    // HUD tensions
    ui.hudR1.textContent = fmtKN1(state.T1);
    ui.hudR2.textContent = fmtKN1(state.T3);
    positionHUD(10);
  }
  function drawStateWithWind(state){ drawState(state); drawWindParticles(); }

  // ===============================================================
  //                     PRECOMPUTE & ANIMATION
  // ===============================================================

  function pickStartingIndex(framesArr){
    for (let i=anim.idxMin;i<=anim.idxMax;i++) if (framesArr[i]) return i;
    for (let i=0;i<framesArr.length;i++) if (framesArr[i]) return i;
    return -1;
  }
  function findNearestValidIndex(framesArr, targetIdx){
    targetIdx = clamp(targetIdx, 0, framesArr.length-1);
    if (framesArr[targetIdx]) return targetIdx;
    let L=targetIdx-1, R=targetIdx+1;
    while (L>=0 || R<framesArr.length){
      if (L>=0 && framesArr[L]) return L;
      if (R<framesArr.length && framesArr[R]) return R;
      L--; R++;
    }
    return -1;
  }

  function stepAnim(time){
    if (!anim.running) return;

    if (!wind.lastTime) wind.lastTime = time;
    const dt = Math.min(0.05, (time - wind.lastTime)/1000);
    wind.lastTime = time;
    updateWindTargets(); updateWind(dt);

    if (!anim.paused){
      if (!anim.lastTime) anim.lastTime = time;
      const elapsed = time - anim.lastTime;
      if (elapsed >= anim.frameInterval){
        anim.lastTime = time;
        let next = anim.index + anim.dir;
        if (next > anim.idxMax || next < anim.idxMin){ anim.dir *= -1; next = anim.index + anim.dir; }
        let tries = anim.idxMax - anim.idxMin + 1;
        while (tries-- > 0 && (!frames[next])){
          next += anim.dir;
          if (next > anim.idxMax || next < anim.idxMin){ anim.dir *= -1; next = clamp(next, anim.idxMin, anim.idxMax); }
        }
        anim.index = clamp(next, anim.idxMin, anim.idxMax);
        const state = frames[anim.index];
        if (state){
          suppressSliderInput = true;
          params.d1 = state.d1;
          ui.d1.value = String(Math.round(state.d1));
          ui.vD1.textContent = Math.round(state.d1);
          suppressSliderInput = false;
          drawStateWithWind(state);
          setStatus('Animating.', 'ok');
        }
      } else {
        const state = frames[anim.index]; if (state) drawStateWithWind(state);
      }
    } else {
      const state = frames[anim.index]; if (state) drawStateWithWind(state);
    }
    requestAnimationFrame(stepAnim);
  }

  function applyDiscreteL2SliderMode(enable){
    if (enable){
      // Save current slider settings
      l2SliderSaved = { min: ui.l2.min, max: ui.l2.max, step: ui.l2.step };
      // Snap to nearest discrete step and set slider to discrete grid
      const idx = nearestL2Index(params.l2);
      currentL2Index = (idx>=0? idx : 0);
      const snapped = L2_STEPS[currentL2Index];
      params.l2 = snapped;
      ui.l2.min  = String(L2min.toFixed(3));
      ui.l2.max  = String(L2max.toFixed(3));
      ui.l2.step = String(L2stepSize.toFixed(6));
      ui.l2.value= String(snapped.toFixed(3));
      ui.vL2.textContent = Math.round(snapped);
    } else {
      // Restore continuous slider
      ui.l2.min  = l2SliderSaved.min;
      ui.l2.max  = l2SliderSaved.max;
      ui.l2.step = l2SliderSaved.step;
    }
  }

  function startAnimation(){
    stopWindLoop();

    // Build L2 discrete set and precompute for winds × 20 L2s
    precompAll();

    if (precompByL2Wind.size === 0){
      setStatus('No valid mass positions for this geometry. Adjust lengths/anchors.', 'bad');
      startWindLoop();
      return;
    }

    // Snap current L2 to discrete grid, enable discrete slider mode
    applyDiscreteL2SliderMode(true);

    // Choose frames for current L2 & wind
    anim.windStep = nearestWindStep(params.Fw_b);
    const mapWind = precompByL2Wind.get(L2_STEPS[currentL2Index]);
    frames = mapWind ? (mapWind.get(anim.windStep) || []) : [];

    // If empty at this L2, search nearest L2 with valid frames
    if (!frames.length || pickStartingIndex(frames) === -1){
      let found = false;
      for (let radius=1; radius<L2_STEPS.length; radius++){
        for (const sign of [-1, +1]){
          const j = currentL2Index + sign*radius;
          if (j<0 || j>=L2_STEPS.length) continue;
          const mw = precompByL2Wind.get(L2_STEPS[j]);
          const fr = mw ? (mw.get(anim.windStep)||[]) : [];
          if (fr.length && pickStartingIndex(fr) !== -1){
            currentL2Index = j; frames = fr; found = true; break;
          }
        }
        if (found) break;
      }
      if (!found){
        setStatus('No valid mass positions across L2 steps. Adjust lengths/anchors.', 'bad');
        startWindLoop();
        return;
      }
    }

    const startIdx = pickStartingIndex(frames);
    anim.running=true; anim.paused=false; anim.index=startIdx; anim.dir=1; anim.lastTime=0; wind.lastTime=0;
    ui.btnPlayPause.disabled=false; ui.btnPlayPause.textContent='Pause';
    setStatus('Animating.', 'ok');
    drawStateWithWind(frames[anim.index]);
    requestAnimationFrame(stepAnim);
  }

  function precompAll(){
    precompByL2Wind.clear();

    if (!computeL2Steps()){
      return;
    }
    const {A1,A2} = anchors();
    const L1 = params.l1, D2 = A2.x, H1 = A1.y;

    for (const L2 of L2_STEPS){
      // Prepare β cache per (L1,L2,D2,H1)
      if (!updateBetaWindowCache(L1, L2, D2, H1)){
        precompByL2Wind.set(L2, new Map()); // mark empty
        continue;
      }
      const mapWind = new Map();
      for (const w of WIND_STEPS){
        mapWind.set(w, precomputeForL2Wind(L2, w));
      }
      precompByL2Wind.set(L2, mapWind);
    }
  }

  function togglePlayPause(){
    if (!anim.running) return;
    anim.paused = !anim.paused;
    ui.btnPlayPause.textContent = anim.paused ? 'Play' : 'Pause';
    setStatus(anim.paused ? 'Paused.' : 'Animating.', anim.paused ? 'warn' : 'ok');
    if (!anim.paused){ anim.lastTime=0; wind.lastTime=0; }
  }

  // ===============================================================
  //                            UI WIRING
  // ===============================================================

  function setupCanvas(){
    const c=ui.canvas, pr=ui.devicePR, parent=c.parentElement, pad=2;
    const w=Math.max(320, parent.clientWidth - pad*2);
    const h=Math.max(280, parent.clientHeight - pad*2);
    c.style.width=w+'px'; c.style.height=h+'px';
    c.width=Math.floor(w*pr); c.height=Math.floor(h*pr);
    ui.ctx=c.getContext('2d'); ui.ctx.setTransform(pr,0,0,pr,0,0);
    drawPreviewWithWind();
    positionHUD(10);
  }
  window.addEventListener('resize', ()=>{
    setupCanvas();
    if (!anim.running && wind.loopActive) initWindParticles();
  }, {passive:true});

  function manageWindLoop(){
    if (!anim.running && params.windVisible) startWindLoop();
    else if (!anim.running) stopWindLoop();
  }

  function syncUIGeometry(){
    params.l1=+ui.l1.value;
    params.d1=clamp(+ui.d1.value, 0, params.l1);
    params.h1=+ui.h1.value;
    params.l2=+ui.l2.value;
    params.d2=+ui.d2.value;

    ui.vL1.textContent=params.l1;
    ui.vD1.textContent=params.d1;
    ui.vH1.textContent=params.h1;
    ui.vL2.textContent=Math.round(params.l2);
    ui.vD2.textContent=params.d2;

    ui.d1.max=String(params.l1);

    // Reset animation & caches; restore continuous L2 slider
    if (anim.running){
      anim.running=false; anim.paused=false; frames=[];
      ui.btnPlayPause.disabled=true; ui.btnPlayPause.textContent='Pause';
      applyDiscreteL2SliderMode(false);
    } else {
      // not running, ensure slider is continuous
      applyDiscreteL2SliderMode(false);
    }
    drawPreviewWithWind();
    setStatus('Adjusted geometry. Click “Simulate” to precompute (winds × 20 L2 steps).', '');
    manageWindLoop();
    positionHUD(10);
  }

  // D1 slider interactions (pause on drag)
  ui.d1.addEventListener('pointerdown', ()=>{
    if (anim.running && !anim.paused){
      anim.paused=true; ui.btnPlayPause.textContent='Play'; anim.autoResumeAfterDrag=true;
      setStatus('Paused (slider drag).', 'warn');
    }
    isDraggingSlider=true;
  }, {passive:true});
  window.addEventListener('pointerup', ()=>{
    if (isDraggingSlider){
      isDraggingSlider=false;
      if (anim.running && anim.autoResumeAfterDrag){
        const idxTarget = Math.round((params.d1/params.l1)*(N_FRAMES-1));
        const nearest   = findNearestValidIndex(frames, idxTarget);
        if (nearest !== -1) anim.index = nearest;
        anim.paused=false; anim.autoResumeAfterDrag=false; ui.btnPlayPause.textContent='Pause';
        setStatus('Animating.', 'ok'); anim.lastTime=0; wind.lastTime=0;
      }
    }
  }, {passive:true});
  ui.d1.addEventListener('input', ()=>{
    if (suppressSliderInput) return;
    params.d1 = clamp(+ui.d1.value, 0, params.l1);
    ui.vD1.textContent = params.d1;
    if (anim.running){
      const idxTarget = Math.round((params.d1/params.l1)*(N_FRAMES-1));
      const nearest = findNearestValidIndex(frames, idxTarget);
      if (nearest !== -1){ anim.index = nearest; const s=frames[anim.index]; if (s) { drawStateWithWind(s); positionHUD(10); } }
      else setStatus('No valid equilibrium at this D1 for current wind/L2.', 'bad');
    } else {
      drawPreviewWithWind(); positionHUD(10);
    }
  }, {passive:true});

  // Geometry sliders (L1, L2, D2, H1) — geometry change resets sim (as before)
  ['l1','l2','d2','h1'].forEach(id=>ui[id].addEventListener('input', ()=>{
    if (id==='l1'){
      const newMax=+ui.l1.value, newD1=clamp(+ui.d1.value, 0, newMax);
      ui.d1.max=String(newMax);
      if (+ui.d1.value !== newD1){
        suppressSliderInput=true; ui.d1.value=String(newD1); suppressSliderInput=false;
      }
    }
    // If the animation is running and the user moves L2,
    // switch to discrete scrubbing instead of resetting.
    if (anim.running && id==='l2'){
      // Snap to nearest precomputed L2 and switch frames; keep animating.
      const desired = +ui.l2.value;
      const idx = nearestL2Index(desired);
      if (idx !== -1){
        currentL2Index = idx;
        const snapped = L2_STEPS[currentL2Index];
        params.l2 = snapped;
        ui.vL2.textContent = Math.round(snapped);
        ui.l2.value = String(snapped.toFixed(3));

        const mapWind = precompByL2Wind.get(snapped);
        const newFrames = mapWind ? (mapWind.get(anim.windStep) || []) : [];
        if (newFrames.length){
          // Preserve D1 if possible
          const idxTarget = Math.round((params.d1/params.l1)*(N_FRAMES-1));
          let nearest = findNearestValidIndex(newFrames, idxTarget);
          if (nearest === -1) nearest = pickStartingIndex(newFrames);
          if (nearest !== -1){
            frames = newFrames; anim.index = nearest; anim.lastTime=0; wind.lastTime=0;
            const s = frames[anim.index]; if (s) { drawStateWithWind(s); positionHUD(10); }
            setStatus('Animating.', 'ok');
          } else {
            setStatus('No valid frames at this L2. Try another step.', 'bad');
          }
        } else {
          setStatus('No valid frames at this L2. Try another step.', 'bad');
        }
      }
      return; // do not reset the animation
    }
    // Otherwise, treat as a geometry change (reset)
    syncUIGeometry();
  }, {passive:true}));

  // Wind slider: live switch among precomputed wind sets (keeps L2 discrete if running)
  ui.fw.addEventListener('input', ()=>{
    params.Fw_b = +ui.fw.value;
    ui.vFW.textContent = params.Fw_b;
    updateWindTargets();

    if (anim.running){
      const newStep = nearestWindStep(params.Fw_b);
      if (newStep !== anim.windStep){
        anim.windStep = newStep;
        const L2val = L2_STEPS[currentL2Index];
        const mapWind = precompByL2Wind.get(L2val);
        let framesArr = mapWind ? (mapWind.get(newStep) || []) : [];
        if (!framesArr.length){
          setStatus('No valid mass positions for this wind at current L2.', 'bad');
        } else {
          frames = framesArr;
          const idxTarget = Math.round((params.d1/params.l1)*(N_FRAMES-1));
          let nearest = findNearestValidIndex(frames, idxTarget);
          if (nearest === -1) nearest = pickStartingIndex(frames);
          if (nearest !== -1){
            anim.index = nearest; anim.lastTime=0; wind.lastTime=0;
            const s = frames[anim.index]; if (s) { drawStateWithWind(s); positionHUD(10); }
          }
        }
      } else {
        const s = frames[anim.index]; if (s) { drawStateWithWind(s); positionHUD(10); }
      }
    } else {
      drawPreviewWithWind();
      manageWindLoop();
      positionHUD(10);
    }
  }, {passive:true});

  // Buttons
  ui.btnSim.addEventListener('click', ()=>{
    startAnimation();
    positionHUD(10);
  });
  ui.btnPlayPause.addEventListener('click', togglePlayPause);

  // Wind visibility
  ui.windVisible.addEventListener('input', ()=>{
    params.windVisible = !!ui.windVisible.checked;
    updateWindTargets();
    if (!anim.running) manageWindLoop();
  }, {passive:true});

  // -------- Canvas bootstrapping --------
  function setupCanvasFirst(){
    const c=ui.canvas, pr=ui.devicePR, parent=c.parentElement, pad=2;
    const w=Math.max(320, parent.clientWidth - pad*2);
    const h=Math.max(280, parent.clientHeight - pad*2);
    c.style.width=w+'px'; c.style.height=h+'px';
    c.width=Math.floor(w*pr); c.height=Math.floor(h*pr);
    ui.ctx=c.getContext('2d'); ui.ctx.setTransform(pr,0,0,pr,0,0);
  }
  function init(){
    setupCanvasFirst();
    ui.vL1.textContent=params.l1; ui.vD1.textContent=params.d1; ui.vH1.textContent=params.h1;
    ui.vL2.textContent=Math.round(params.l2); ui.vD2.textContent=params.d2;
    ui.vFW.textContent=params.Fw_b;
    params.windVisible = !!ui.windVisible.checked;
    initWindParticles(); updateWindTargets(); drawPreviewWithWind();
    positionHUD(10);
    if (params.windVisible) startWindLoop();
  }
  init();
})();
</script>
</body>
</html>
